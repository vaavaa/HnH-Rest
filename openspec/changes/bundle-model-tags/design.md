# Design — Bundle Model Tags

**Change ID**: `bundle-model-tags`  
**Branch**: `spec/bundle-model-tags`  
**Date**: 2026-02-23

Перед реализацией прочитать проектную спецификацию `openspec/specs/000-repo-and-deps.md` и дизайн/спеки Prompt Spec v1 (модели, API, порядок сборки).

---

## 1. Изменения в БД

### 1.1 Таблица `prompt_bundle`

Добавить столбец:

- **tags** — `JSONB` (PostgreSQL). Список строк-тегов, например `["gpt-4o", "default"]` или `[]`.
  - Ограничения: не null; по умолчанию `'[]'::jsonb`.
  - Не входит в уникальное ограничение: остаётся `UNIQUE(bundle_id, semver)`.

Миграция Alembic:

- Добавить столбец `tags` (JSONB, nullable=False, server_default=sa.text("'[]'::jsonb")).
- Для существующих строк: установить только `tags = '[]'::jsonb` (пустой массив).

Индексы (по необходимости):

- GIN-индекс по `tags` для запросов «в массиве содержится значение» — опционально, в зависимости от объёма данных и частоты фильтрации.

---

## 2. Изменения в API

### 2.1 POST /v1/prompts/bundles

- **Request**: добавить опциональное поле `tags: list[str] | None = None`.
  - Если не передано — сохранять как `[]`.
  - Валидация: каждый элемент — непустая строка, разумная длина (например до 64 символов); дубликаты в списке не допускаются или нормализовать до уникальных.

- Остальные поля без изменений.

### 2.2 GET /v1/prompts/bundles/{bundle_id}

- **Response**: в DTO бандла включить поле `tags: list[str]`.
- Опционально: query-параметр `?model_type=...` — фильтровать возвращаемые версии бандла только теми, у которых в `tags` есть указанный тег. Если не передан — поведение как сейчас (все версии по `bundle_id`).

### 2.3 POST /v1/prompts/render

- **Request**: добавить опциональное поле `model_type: str | None = None`.
- **Логика**:
  1. Найти бандл по `(bundle_id, semver)` как сейчас.
  2. Если `model_type` передан и не пустая строка (после strip):
     - проверить, что в `bundle.tags` есть элемент, равный `model_type` (сравнение по строке, чувствительно к регистру);
     - если нет — вернуть **400 Bad Request** с телом ошибки по формату ниже.
  3. Если `model_type` не передан или пустая строка (после strip) — проверку по тегам не выполнять (обратная совместимость).

**Формат тела ошибки 400 при неподдерживаемом model_type:**

- HTTP status: **400**
- Content-Type: `application/json`
- Тело (JSON):
  - **detail** (string): сообщение для разработчика, например «Bundle does not support model_type 'X'».
  - **code** (string): константа `"bundle_unsupported_model"` — для программной обработки на клиенте.

---

## 3. Модели и схемы

### 3.1 SQLAlchemy PromptBundle

- Добавить атрибут `tags`: `sa.Column(JSONB, nullable=False, server_default=sa.text("'[]'::jsonb"))`.

### 3.2 Pydantic

- **BundleCreate**: `tags: list[str] | None = None`; нормализация в список уникальных непустых строк; по умолчанию `[]`.
- **BundleRead**: `tags: list[str]`.
- **RenderRequest**: `model_type: str | None = None`.

---

## 4. Сервисы

- **BundleService.create**: при создании бандла записывать `tags` (нормализованный список).
- **RendererService.render** (или слой, который резолвит бандл): после загрузки бандла по `(bundle_id, semver)` при переданном непустом `model_type` проверять вхождение в `bundle.tags`; при отсутствии — вызывать исключение для маппинга в **400** с телом `{ "detail": "...", "code": "bundle_unsupported_model" }`.

---

## 5. Обратная совместимость

- Старые клиенты не передают `model_type` — render работает как раньше.
- Старые строки в БД после миграции имеют только `tags = '[]'::jsonb`; при запросе с `model_type=X` такой бандл не подойдёт (в пустом списке нет X), клиент получит 400 с кодом `bundle_unsupported_model`. Для поддержки модели бандл должен содержать соответствующий тег в `tags`.
